<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Dynamic Hand Tree</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #01050a; }
        #container { width: 100vw; height: 100vh; }
        #video-container {
            position: absolute; top: 10px; right: 10px;
            width: 100px; height: 75px; border-radius: 8px; 
            overflow: hidden; transform: scaleX(-1); border: 1px solid #333;
        }
        video { width: 100%; height: 100%; object-fit: cover; }
    </style>
</head>
<body>

<div id="container"></div>
<div id="video-container"><video id="input_video" playsinline></video></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);
    const renderer = new THREE.WebGLRenderer({ antialias: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.2));
    document.getElementById('container').appendChild(renderer.domElement);

    camera.position.z = 8;

    // --- CÂY THÔNG LINH ĐỘNG ---
    const treeCount = 2000;
    const treeGeo = new THREE.BufferGeometry();
    const treePos = new Float32Array(treeCount * 3);
    const treeBase = new Float32Array(treeCount * 3);

    for (let i = 0; i < treeCount; i++) {
        const y = Math.random() * 4;
        const radiusAtY = (4 - y) * 0.5;
        const angle = Math.random() * Math.PI * 2;
        const r = Math.sqrt(Math.random()) * radiusAtY;
        treeBase[i*3] = Math.cos(angle) * r;
        treeBase[i*3+1] = y - 2;
        treeBase[i*3+2] = Math.sin(angle) * r;
    }
    treeGeo.setAttribute('position', new THREE.BufferAttribute(treePos, 3));
    const treeMat = new THREE.PointsMaterial({ size: 0.06, color: 0x00ff88, transparent: true, opacity: 0 });
    const tree = new THREE.Points(treeGeo, treeMat);
    scene.add(tree);

    // --- BIẾN ĐIỀU KHIỂN ---
    let targetPos = new THREE.Vector3(0, 0, 0);
    let currentPos = new THREE.Vector3(0, 0, 0);
    let targetScale = 1;
    let currentScale = 1;
    let isVisible = false;

    // --- XỬ LÝ AI ---
    const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
    hands.setOptions({ maxNumHands: 2, modelComplexity: 0, minDetectionConfidence: 0.5 });

    hands.onResults((res) => {
        if (res.multiHandLandmarks && res.multiHandLandmarks.length >= 2) {
            isVisible = true;
            const h1 = res.multiHandLandmarks[0][0];
            const h2 = res.multiHandLandmarks[1][0];

            // 1. Tính tâm điểm giữa 2 tay (Normalize 0->1 sang không gian 3D)
            const midX = ((h1.x + h2.x) / 2 - 0.5) * -15; // Nhân hệ số để phủ kín màn hình
            const midY = ((h1.y + h2.y) / 2 - 0.5) * -10 + 2;
            targetPos.set(midX, midY, 0);

            // 2. Tính độ rộng thu phóng
            const dist = Math.sqrt(Math.pow(h1.x - h2.x, 2) + Math.pow(h1.y - h2.y, 2));
            targetScale = dist * 4.5;
        } else {
            isVisible = false;
        }
    });

    const videoElement = document.getElementById('input_video');
    new Camera(videoElement, {
        onFrame: async () => await hands.send({image: videoElement}),
        width: 320, height: 240
    }).start();

    // --- VÒNG LẶP RENDER ---
    function animate() {
        requestAnimationFrame(animate);

        // Nội suy vị trí (Lerp) - giúp cây thông "đuổi" theo tay mượt mà
        currentPos.lerp(targetPos, 0.15);
        currentScale = THREE.MathUtils.lerp(currentScale, targetScale, 0.2);
        
        // Hiệu ứng mờ dần khi mất dấu tay
        treeMat.opacity = THREE.MathUtils.lerp(treeMat.opacity, isVisible ? 1 : 0, 0.1);

        const p = treeGeo.attributes.position.array;
        for (let i = 0; i < treeCount; i++) {
            // Cập nhật vị trí hạt dựa trên tâm của tay (currentPos)
            p[i*3] = treeBase[i*3] * currentScale + currentPos.x;
            p[i*3+1] = treeBase[i*3+1] + currentPos.y;
            p[i*3+2] = treeBase[i*3+2] * currentScale + currentPos.z;
        }
        treeGeo.attributes.position.needsUpdate = true;
        tree.rotation.y += 0.02;

        renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
