<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Xmas Tree Gesture Control</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020b16; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #container { width: 100vw; height: 100vh; }
        #video-container {
            position: absolute; bottom: 20px; right: 20px;
            width: 180px; height: 135px; border: 2px solid rgba(255,255,255,0.3);
            border-radius: 12px; overflow: hidden; transform: scaleX(-1);
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }
        video { width: 100%; height: 100%; object-fit: cover; }
        .ui-overlay {
            position: absolute; top: 20px; left: 20px; color: white;
            background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px);
            padding: 20px; border-radius: 15px; border: 1px solid rgba(255,255,255,0.2);
            pointer-events: none;
        }
        h2 { margin: 0 0 10px 0; color: #ffcf40; font-size: 1.2rem; }
        p { margin: 5px 0; font-size: 0.9rem; opacity: 0.9; }
    </style>
</head>
<body>

<div id="container"></div>
<div id="video-container"><video id="input_video"></video></div>
<div class="ui-overlay">
    <h2>üéÑ C√¢y Th√¥ng Tuy·∫øt 3D</h2>
    <p>‚Ä¢ <b>X√≤e/Kh√©p 2 tay:</b> ƒê·ªÉ l√†m c√¢y th√¥ng "n·ªü hoa" ho·∫∑c thu nh·ªè.</p>
    <p>‚Ä¢ <b>Tuy·∫øt r∆°i:</b> T·ªëc ƒë·ªô c·ªë ƒë·ªãnh, ph·∫£n h·ªìi th·ªùi gian th·ª±c.</p>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/dat.gui/build/dat.gui.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
    // --- KH·ªûI T·∫†O SCENE ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x020b16, 0.15);
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.getElementById('container').appendChild(renderer.domElement);

    camera.position.set(0, 2, 8);

    // --- H·ªÜ TH·ªêNG H·∫†T (C√ÇY TH√îNG) ---
    const treeParticleCount = 6000;
    const treeGeometry = new THREE.BufferGeometry();
    const treePositions = new Float32Array(treeParticleCount * 3);
    const treeBaseCoords = new Float32Array(treeParticleCount * 3);

    for (let i = 0; i < treeParticleCount; i++) {
        // Thu·∫≠t to√°n t·∫°o h√¨nh c√¢y th√¥ng (n√≥n x·∫øp t·∫ßng)
        const y = Math.random() * 5; // Chi·ªÅu cao 5 ƒë∆°n v·ªã
        const layer = Math.floor(y); 
        const radiusAtY = (5 - y) * 0.4; // ƒê∆∞·ªùng k√≠nh h·∫πp d·∫ßn khi l√™n cao
        
        const angle = Math.random() * Math.PI * 2;
        const r = Math.sqrt(Math.random()) * radiusAtY;

        const x = Math.cos(angle) * r;
        const z = Math.sin(angle) * r;

        treeBaseCoords[i*3] = x;
        treeBaseCoords[i*3+1] = y - 2; // CƒÉn gi·ªØa theo tr·ª•c Y
        treeBaseCoords[i*3+2] = z;
    }

    treeGeometry.setAttribute('position', new THREE.BufferAttribute(treePositions, 3));
    const treeMaterial = new THREE.PointsMaterial({
        size: 0.04,
        color: 0x228b22, // Xanh l√° th√¥ng
        transparent: true,
        blending: THREE.AdditiveBlending
    });
    const tree = new THREE.Points(treeGeometry, treeMaterial);
    scene.add(tree);

    // --- H·ªÜ TH·ªêNG TUY·∫æT R∆†I ---
    const snowCount = 2000;
    const snowGeo = new THREE.BufferGeometry();
    const snowPos = new Float32Array(snowCount * 3);
    for(let i=0; i<snowCount*3; i++) {
        snowPos[i] = (Math.random() - 0.5) * 20;
    }
    snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPos, 3));
    const snowMat = new THREE.PointsMaterial({ size: 0.05, color: 0xffffff, transparent: true, opacity: 0.8 });
    const snow = new THREE.Points(snowGeo, snowMat);
    scene.add(snow);

    // --- GIAO DI·ªÜN ƒêI·ªÄU KHI·ªÇN ---
    const config = { treeColor: '#228b22', snowSpeed: 0.02 };
    const gui = new dat.GUI();
    gui.addColor(config, 'treeColor').name('M√†u l√° th√¥ng').onChange(c => treeMaterial.color.set(c));
    gui.add(config, 'snowSpeed', 0, 0.1).name('T·ªëc ƒë·ªô tuy·∫øt');

    // --- NH·∫¨N DI·ªÜN C·ª¨ CH·ªà ---
    const videoElement = document.getElementById('input_video');
    let targetScale = 1;

    function onResults(results) {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length >= 2) {
            const h1 = results.multiHandLandmarks[0][0];
            const h2 = results.multiHandLandmarks[1][0];
            const dist = Math.sqrt(Math.pow(h1.x - h2.x, 2) + Math.pow(h1.y - h2.y, 2));
            targetScale = THREE.MathUtils.mapLinear(dist, 0.1, 0.7, 0.5, 4);
        } else {
            targetScale = 1;
        }
    }

    const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
    hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5 });
    hands.onResults(onResults);

    new Camera(videoElement, {
        onFrame: async () => await hands.send({image: videoElement}),
        width: 640, height: 480
    }).start();

    // --- ANIMATION ---
    let currentScale = 1;

    function animate() {
        requestAnimationFrame(animate);
        
        // C·∫≠p nh·∫≠t c√¢y th√¥ng
        currentScale = THREE.MathUtils.lerp(currentScale, targetScale, 0.1);
        const positions = treeGeometry.attributes.position.array;
        for (let i = 0; i < treeParticleCount; i++) {
            positions[i*3] = treeBaseCoords[i*3] * currentScale;
            positions[i*3+1] = treeBaseCoords[i*3+1]; // Gi·ªØ chi·ªÅu cao
            positions[i*3+2] = treeBaseCoords[i*3+2] * currentScale;
        }
        treeGeometry.attributes.position.needsUpdate = true;
        tree.rotation.y += 0.005;

        // C·∫≠p nh·∫≠t tuy·∫øt r∆°i
        const sPos = snowGeo.attributes.position.array;
        for(let i=1; i<snowCount*3; i+=3) {
            sPos[i] -= config.snowSpeed;
            if(sPos[i] < -5) sPos[i] = 10; // Reset tuy·∫øt khi r∆°i xu·ªëng th·∫•p
        }
        snowGeo.attributes.position.needsUpdate = true;

        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>
